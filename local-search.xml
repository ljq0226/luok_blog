<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/luok_blog/2022/11/19/hello-world/"/>
    <url>/luok_blog/2022/11/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试</title>
    <link href="/luok_blog/2022/11/13/test/"/>
    <url>/luok_blog/2022/11/13/test/</url>
    
    <content type="html"><![CDATA[<h2 id="一、数组基础"><a href="#一、数组基础" class="headerlink" title="一、数组基础"></a>一、数组基础</h2><h3 id="1-数组概述"><a href="#1-数组概述" class="headerlink" title="1. 数组概述"></a>1. 数组概述</h3><p>数组是我们最常用的数据类型之一，ECMAScript数组跟其他语言的数组一样，都是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。除此之外，ECMAScript数组的长度也是动态的，会随着数据的增删而改变。</p><p>数组是被等分为许多小块的连续内存段，每个小块都和一个整数关联，可以通过这个整数快速访问对应的小块。除此之外，数组拥有一个length属性，该属性表示的并不是数组元素的数量，而是指数组元素的最高序号加1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>a.<span class="hljs-property">length</span> === <span class="hljs-number">3</span>  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>在ES6中，可以使用扩展运算符（…）来获取数组元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> b = [<span class="hljs-number">0</span>, ...a, <span class="hljs-number">4</span>];  <span class="hljs-comment">// [0, 1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><h3 id="2-数组创建"><a href="#2-数组创建" class="headerlink" title="2. 数组创建"></a>2. 数组创建</h3><p>数组的创建方式有以下两种。</p><h4 id="（1）字面量"><a href="#（1）字面量" class="headerlink" title="（1）字面量"></a>（1）字面量</h4><p>最常用的创建数组的方式就是<strong>数组字面量，</strong>数组元素的类型可以是任意的，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&quot;red&quot;</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-literal">true</span>];  <br></code></pre></td></tr></table></figure><h4 id="（2）构造函数"><a href="#（2）构造函数" class="headerlink" title="（2）构造函数"></a>（2）构造函数</h4><p>使用构造函数创建数组的形式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(); <br></code></pre></td></tr></table></figure><p>如果已知数组元素数量，那么就可以给构造函数传入一个数值，然后length属性就会被自动创建并保存这个值，比如创建一个长度为10的数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();  <span class="hljs-comment">// [undefined × 10]</span><br></code></pre></td></tr></table></figure><p>这样，就可以创建一个长度为10的数组，数组每个元素的值都是undefined。</p><p>还可以给Array构造函数传入要保存的元素，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> colors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>);  <br></code></pre></td></tr></table></figure><p>这就出现问题了，当我们创建数组时，如果给数组传入一个值，如果传入的值是数字，那么就会创建一个长度为指定数字的数组；如果这个值是其他类型，就会创建一个质保函该特定制度额数组。这样我们就无法直接创建一个只包含一个数字的数组了。</p><p>Array 构造函数根据参数长度的不同，有如下两种不同的处理方式：</p><ul><li>**new Array(arg1, arg2,…)**：参数长度为 0 或长度大于等于 2 时，传入的参数将按照顺序依次成为新数组的第 0 至第 N 项（参数长度为 0 时，返回空数组）；</li><li>**new Array(length)**：当 length 不是数值时，返回一个只包含 length 元素一项的数组；当 length 为数值时，length 最大不能超过 32 位无符号整型，即需要小于 232，否则将抛出 RangeError。</li></ul><p>在使用Array构造函数时，也可以省略 new 操作符，结果是一样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = <span class="hljs-title class_">Array</span>();  <br></code></pre></td></tr></table></figure><h4 id="（3）ES6-构造器"><a href="#（3）ES6-构造器" class="headerlink" title="（3）ES6 构造器"></a>（3）ES6 构造器</h4><p>鉴于数组的常用性，ES6 专门扩展了数组构造器 Array ，新增了 2 个方法：Array.of和Array.from。Array.of 用得比较少，Array.from 具有很强的灵活性。</p><p><strong>1）Array.of</strong><br>Array.of 用于<strong>将参数依次转化为数组项</strong>，然后返回这个新数组。它基本上与 Array 构造器功能一致，唯一的区别就在单个数字参数的处理上。</p><p>比如，在下面的代码中，可以看到：当参数为2个时，返回的结果是一致的；当参数是一个时，Array.of 会把参数变成数组里的一项，而构造器则会生成长度和第一个参数相同的空数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">8.0</span>); <span class="hljs-comment">// [8]</span><br><span class="hljs-title class_">Array</span>(<span class="hljs-number">8.0</span>); <span class="hljs-comment">// [empty × 8]</span><br><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">8.0</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// [8, 5]</span><br><span class="hljs-title class_">Array</span>(<span class="hljs-number">8.0</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// [8, 5]</span><br><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-string">&#x27;8&#x27;</span>); <span class="hljs-comment">// [&quot;8&quot;]</span><br><span class="hljs-title class_">Array</span>(<span class="hljs-string">&#x27;8&#x27;</span>); <span class="hljs-comment">// [&quot;8&quot;]</span><br></code></pre></td></tr></table></figure><p><strong>2）Array.from</strong><br>Array.from 的设计初衷是快速基于其他对象创建新数组，准确来说就是从一个类似数组的可迭代对象中创建一个新的数组实例。其实，只要一个对象有迭代器，Array.from 就能把它变成一个数组（注意：该方法会返回一个的数组，不会改变原对象）。</p><p>从语法上看，Array.from 有 3 个参数：</p><ul><li>类似数组的对象，必选；</li><li>加工函数，新生成的数组会经过该函数的加工再返回；</li><li>this 作用域，表示加工函数执行时 this 的值。</li></ul><p>这三个参数里面第一个参数是必选的，后两个参数都是可选的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>:<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(obj, <span class="hljs-keyword">function</span>(<span class="hljs-params">value, index</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value, index, <span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>);<br>  <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">3</span>);   <span class="hljs-comment">//必须指定返回值，否则返回 undefined</span><br>&#125;, obj);<br></code></pre></td></tr></table></figure><p>结果如图：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1611730183856-26a3b305-e13f-420c-ae0b-6e2befdd325f.png#height=89&id=oAFws&margin=%5Bobject%20Object%5D&name=image.png&originHeight=89&originWidth=336&originalType=binary&ratio=1&size=7024&status=done&style=shadow&width=336" alt="image.png"><br>以上结果表明，通过 Array.from 这个方法可以自定义加工函数的处理方式，从而返回想要得到的值；如果不确定返回值，则会返回 undefined，最终生成的是一个包含若干个 undefined 元素的空数组。</p><p>实际上，如果这里不指定 this，加工函数就可以是一个箭头函数。上述代码可以简写为以下形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(obj, <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> value.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">3</span>));<br><span class="hljs-comment">//  控制台打印 (3) [&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;]</span><br></code></pre></td></tr></table></figure><p>除了上述 obj 对象以外，拥有迭代器的对象还包括 String、Set、Map 等，<code>Array.from</code> 都可以进行处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// String</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;abc&#x27;</span>);                             <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="hljs-comment">// Set</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;def&#x27;</span>]));           <span class="hljs-comment">// [&quot;abc&quot;, &quot;def&quot;]</span><br><span class="hljs-comment">// Map</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;ab&#x27;</span>], [<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;de&#x27;</span>]]));   <span class="hljs-comment">// [[1, &#x27;ab&#x27;], [2, &#x27;de&#x27;]]</span><br></code></pre></td></tr></table></figure><h3 id="3-数组空位"><a href="#3-数组空位" class="headerlink" title="3. 数组空位"></a>3. 数组空位</h3><p>当我们使用数组字面量初始化数组时，可以使用一串逗号来创建空位，ECMAScript会将逗号之间相应索引位置的值当成空位，ES6 重新定义了该如何处理这些空位。</p><p>我们可以这样来创建一个空位数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [,,,,,];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-property">length</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array)<br></code></pre></td></tr></table></figure><p>运行结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1628425506519-3de80030-b418-4062-bed8-7a40f86ac2d1.png#height=113&id=jrEPd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=226&originWidth=504&originalType=binary&ratio=1&size=20090&status=done&style=shadow&width=252" alt="image.png"><br>ES6新增的方法和迭代器与早期版本中存在的方法的行为不同，ES6新增方法普遍将这些空位当成存在的元素，只不过值为undefined，使用字面量形式创建如下数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>,,,<span class="hljs-number">5</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> array)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i === <span class="hljs-literal">undefined</span>)<br>&#125;<br><span class="hljs-comment">// 输出结果：false true true false</span><br></code></pre></td></tr></table></figure><p>使用ES6的Array.form创建数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>,,,<span class="hljs-number">5</span>]);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> array)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i === <span class="hljs-literal">undefined</span>)<br>&#125;<br><span class="hljs-comment">// 输出结果：false true true false</span><br></code></pre></td></tr></table></figure><p>而ES6之前的方法则会忽略这个空位：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>,,,<span class="hljs-number">5</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-number">10</span>))<br><br><span class="hljs-comment">// 输出结果：[10, undefined, undefined, 10]</span><br></code></pre></td></tr></table></figure><p>由于不同方法对空位数组的处理方式不同，因此尽量避免使用空位数组。</p><h3 id="4-数组索引"><a href="#4-数组索引" class="headerlink" title="4. 数组索引"></a>4. 数组索引</h3><p>在数组中，我们可以通过使用数组的索引来获取数组的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> colors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>);  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array[<span class="hljs-number">1</span>])  <span class="hljs-comment">// blue</span><br></code></pre></td></tr></table></figure><p>如果指定的索引值小于数组的元素数，就会返回存储在相应位置的元素，也可以通过这种方式来设置一个数组元素的值。如果设置的索引值大于数组的长度，那么就会将数组长度扩充至该索引值加一。</p><p>数组长度length的独特之处在于，他不是只读的。通过length属性，可以在数组末尾增加删除元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> colors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>);  <br>colors.<span class="hljs-property">length</span> = <span class="hljs-number">2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(colors[<span class="hljs-number">2</span>])  <span class="hljs-comment">// undefined</span><br><br>colors.<span class="hljs-property">length</span> = <span class="hljs-number">4</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(colors[<span class="hljs-number">3</span>])  <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>数组长度始终比数组最后一个值的索引大1，这是因为索引值都是从0开始的。</p><h3 id="5-数组判断"><a href="#5-数组判断" class="headerlink" title="5. 数组判断"></a>5. 数组判断</h3><p>一个很经典的ECMASript问题就是如何判断一个对象是不是数组，下面来看常用的数据类型检测的方法。</p><p>在 ES6 之前，至少有如下 5 种方式去判断一个对象是否为数组。</p><ul><li><p>通过**Object.prototype.toString.call()**做判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>,-<span class="hljs-number">1</span>) === <span class="hljs-string">&#x27;Array&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>通过<strong>constructor</strong>做判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span>;<br></code></pre></td></tr></table></figure></li><li><p>通过<strong>instanceof</strong>做判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span><br></code></pre></td></tr></table></figure></li><li><p>通过<strong>Array.prototype.isPrototypeOf</strong>做判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(obj)<br></code></pre></td></tr></table></figure></li><li><p>通过基于<strong>getPrototypeOf</strong>做判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj) === <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br></code></pre></td></tr></table></figure><p>如果obj是一个数组，那么上面这 5 个判断全部为 true，推荐通过 Object.prototype.toString 去判断一个值的类型。</p></li></ul><p>ES6 新增了 <code>Array.isArray</code> 方法，可以直接判断数据类型是否为数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArrray</span>(obj);<br></code></pre></td></tr></table></figure><p>如果 isArray 不存在，那么 <code>Array.isArray</code> 的 polyfill 通常可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-property">isArray</span>)&#123;<br>  <span class="hljs-title class_">Array</span>.<span class="hljs-property">isArray</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">arg</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(arg) === <span class="hljs-string">&#x27;[object Array]&#x27;</span>;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、数组方法"><a href="#二、数组方法" class="headerlink" title="二、数组方法"></a>二、数组方法</h2><p>数字就像是一个森林，里面有很多函“树”，有些方法纯净如水，并不会改变原数组，有些则会改变原数组。</p><ul><li><p>改变原数组的方法：fill()、pop()、push()、shift()、splice()、unshift()、reverse()、sort()；</p></li><li><p>不改变原数组的方法：concat()、every()、filter()、find()、findIndex()、forEach()、indexOf()、join()、lastIndexOf()、map()、reduce()、reduceRight()、slice()、some。</p><h3 id="1-复制和填充方法"><a href="#1-复制和填充方法" class="headerlink" title="1. 复制和填充方法"></a>1. 复制和填充方法</h3><p>ES提供了两个方法：批量复制方法copeWithin()，以及填充数组方法fill()。这两个方法的签名类似，都需要指定已有数组实例上的一个范围，包含开始索引，不包含结束索引。下面就分别来看一下这两个方法。</p><h4 id="（1）fill"><a href="#（1）fill" class="headerlink" title="（1）fill()"></a>（1）fill()</h4><p>使用fill()方法可以向一个已有数组中插入全部或部分相同的值，开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。如果是负值，则将从负值加上数组的长度而得到的值开始。该方法的语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.<span class="hljs-title function_">fill</span>(value, start, end)<br></code></pre></td></tr></table></figure><p>其参数如下：</p></li><li><p>_value<strong>：</strong>_必需。填充的值；</p></li><li><p>_start：_可选。开始填充位置；</p></li><li><p>_end：_可选。停止填充位置 (默认为 <em>array</em>.length)。</p></li></ul><p>使用示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];<br><br><span class="hljs-comment">// 用5填充整个数组</span><br>arr.<span class="hljs-title function_">fill</span>(<span class="hljs-number">5</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [5, 5, 5, 5, 5]</span><br>arr.<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);      <span class="hljs-comment">// 重置</span><br><br><span class="hljs-comment">// 用5填充索引大于等于3的元素</span><br>arr.<span class="hljs-title function_">fill</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [0, 0, 0, 5, 5]</span><br>arr.<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);      <span class="hljs-comment">// 重置</span><br><br><span class="hljs-comment">// 用5填充索引大于等于1且小于等于3的元素</span><br>arr.<span class="hljs-title function_">fill</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [0, 5, 5, 0, 0]</span><br>arr.<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);      <span class="hljs-comment">// 重置</span><br><br><span class="hljs-comment">// 用5填充索引大于等于-1的元素</span><br>arr.<span class="hljs-title function_">fill</span>(<span class="hljs-number">5</span>, -<span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [0, 0, 0, 0, 5]</span><br>arr.<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);      <span class="hljs-comment">// 重置</span><br></code></pre></td></tr></table></figure><h4 id="（2）copyWithin"><a href="#（2）copyWithin" class="headerlink" title="（2）copyWithin()"></a>（2）copyWithin()</h4><p>copyWithin()方法会按照指定范围来浅复制数组中的部分内容，然后将它插入到指定索引开始的位置，开始与结束索引的计算方法和fill方法一样。该方法的语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.<span class="hljs-title function_">copyWithin</span>(target, start, end)<br></code></pre></td></tr></table></figure><p>其参数如下：</p><ul><li>_target’<strong>：</strong>_必需。复制到指定目标索引位置；</li><li>_start：_可选。元素复制的起始位置；</li><li>_end：_可选。停止复制的索引位置 (默认为 <em>array</em>.length)。如果为负值，表示倒数。</li></ul><p>使用示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">copyWithin</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>));  <span class="hljs-comment">// [4, 5, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><h3 id="2-转化方法"><a href="#2-转化方法" class="headerlink" title="2. 转化方法"></a>2. 转化方法</h3><p>数组的转化方法主要有四个：toLocaleString()、toString()、valueOf()、join()。下面就分别来看一下这4个方法。</p><h4 id="（1）toString"><a href="#（1）toString" class="headerlink" title="（1）toString()"></a>（1）toString()</h4><p>toString()方法返回的是由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串，也就是说，对数组的每个值都会调用toString()方法，以得到最终的字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(colors.<span class="hljs-title function_">toString</span>())  <span class="hljs-comment">// red,blue,green</span><br></code></pre></td></tr></table></figure><h4 id="（2）valueOf"><a href="#（2）valueOf" class="headerlink" title="（2）valueOf()"></a>（2）valueOf()</h4><p>valueOf()方法返回的是数组本身，如下面代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(colors.<span class="hljs-title function_">valueOf</span>())  <span class="hljs-comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br></code></pre></td></tr></table></figure><h4 id="（3）toLocaleString"><a href="#（3）toLocaleString" class="headerlink" title="（3）toLocaleString()"></a>（3）toLocaleString()</h4><p>toLocaleString()方法可能会返回和toString()方法相同的结果，但也不一定。在调用toLocaleString()方法时会得到一个逗号分隔的数组值的字符串，它与toString()方法的区别是，为了得到最终的字符串，会调用每个值的toLocaleString()方法，而不是toString()方法，看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array= [&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;zz&#x27;</span>&#125;, <span class="hljs-number">123</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()];<br><span class="hljs-keyword">let</span> str = array.<span class="hljs-title function_">toLocaleString</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str); <span class="hljs-comment">// [object Object],123,abc,2016/1/5 下午1:06:23</span><br></code></pre></td></tr></table></figure><p>需要注意，如果数组中的某一项是null或者undefined，则在调用上述三个方法后，返回的结果中会以空字符串来表示。</p><h4 id="（4）join"><a href="#（4）join" class="headerlink" title="（4）join()"></a>（4）join()</h4><p>join() 方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。其使用语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arrayObject.<span class="hljs-title function_">join</span>(separator)<br></code></pre></td></tr></table></figure><p>其中参数separator是可选的，用来指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。</p><p>该方法返回一个字符串。该字符串是通过把 arrayObject 的每个元素转换为字符串，然后把这些字符串连接起来，在两个元素之间插入 separator 字符串而生成的。</p><p>使用示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>,<span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">join</span>());      <span class="hljs-comment">// one,two,three,four,five</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;-&quot;</span>));   <span class="hljs-comment">// one-two-three-four-five</span><br></code></pre></td></tr></table></figure><h3 id="3-栈方法"><a href="#3-栈方法" class="headerlink" title="3. 栈方法"></a>3. 栈方法</h3><p>ECMAScript给数组添加了几个方法来使它像栈一样。众所周知，栈是一种后进先出的结构，也就是最近添加的项先被删除。数据项的插入（称为推入，push），和删除（称为弹出，pop）只在栈顶发生。数组提高了push()和pop()来实现类似栈的行为。下面就分别来看看这两个方法。</p><h4 id="（1）push"><a href="#（1）push" class="headerlink" title="（1）push()"></a>（1）push()</h4><p>push()方法可以接收任意数量的参数，并将它们添加了数组末尾，并返回数组新的长度。<strong>该方法会改变原数组。</strong>其语法形式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arrayObject.<span class="hljs-title function_">push</span>(newelement1,newelement2,....,newelementX)<br></code></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [<span class="hljs-string">&quot;football&quot;</span>, <span class="hljs-string">&quot;basketball&quot;</span>,  <span class="hljs-string">&quot;badminton&quot;</span>];<br><span class="hljs-keyword">let</span> i = array.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;golfball&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array); <span class="hljs-comment">// [&quot;football&quot;, &quot;basketball&quot;, &quot;badminton&quot;, &quot;golfball&quot;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);     <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><h4 id="（2）pop"><a href="#（2）pop" class="headerlink" title="（2）pop()"></a>（2）pop()</h4><p>pop() 方法用于删除并返回数组的最后一个元素。它没有参数。<strong>该方法会改变原数组。</strong>其语法形式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arrayObject.<span class="hljs-title function_">pop</span>()<br></code></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [<span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;cow&quot;</span>, <span class="hljs-string">&quot;chicken&quot;</span>, <span class="hljs-string">&quot;mouse&quot;</span>];<br><span class="hljs-keyword">let</span> item = array.<span class="hljs-title function_">pop</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array); <span class="hljs-comment">// [&quot;cat&quot;, &quot;dog&quot;, &quot;cow&quot;, &quot;chicken&quot;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);  <span class="hljs-comment">// mouse</span><br></code></pre></td></tr></table></figure><h3 id="4-队列方法"><a href="#4-队列方法" class="headerlink" title="4. 队列方法"></a>4. 队列方法</h3><p>队列是一种先进先出的数据结构，队列在队尾添加元素，在对头删除元素。上面我们已经说了在结果添加数据的方法push()，下面就再来看看从数组开头删除和添加元素的方法：shift()和unshift()。实际上unshift()并不属于操作队列的方法，不过这里也一起说了。</p><h4 id="（1）shift"><a href="#（1）shift" class="headerlink" title="（1）shift()"></a>（1）shift()</h4><p>shift()方法会删除数组的第一项，并返回它，然后数组长度减一，<strong>该方法会改变原数组。</strong>语法形式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arrayObject.<span class="hljs-title function_">shift</span>()<br></code></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> item = array.<span class="hljs-title function_">shift</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array); <span class="hljs-comment">// [2,3,4,5]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);  <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>注意：如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。</p><h4 id="（2）unshift"><a href="#（2）unshift" class="headerlink" title="（2）unshift()"></a>（2）unshift()</h4><p>unshift()方法可向数组的开头添加一个或更多元素，并返回新的长度。<strong>该方法会改变原数组。</strong>其语法形式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arrayObject.<span class="hljs-title function_">unshift</span>(newelement1,newelement2,....,newelementX)<br></code></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>];<br><span class="hljs-keyword">let</span> length = array.<span class="hljs-title function_">unshift</span>(<span class="hljs-string">&quot;yellow&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array);  <span class="hljs-comment">// [&quot;yellow&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(length); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><h3 id="5-排序方法"><a href="#5-排序方法" class="headerlink" title="5. 排序方法"></a>5. 排序方法</h3><p>数组有两个方法可以对数组进行重新排序：sort()和reverse()。下面就分别来看看这两个方法。</p><h4 id="（1）sort"><a href="#（1）sort" class="headerlink" title="（1）sort()"></a>（1）sort()</h4><p>sort()方法是我们常用给的数组排序方法，该方法会在原数组上进行排序，会改变原数组，其使用语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arrayObject.<span class="hljs-title function_">sort</span>(sortby)<br></code></pre></td></tr></table></figure><p>其中参数sortby是可选参数，用来规定排序顺序，它是一个比较函数，用来判断哪个值应该排在前面。默认情况下，sort()方法会按照升序重新排列数组元素。为此，sort()方法会在每一个元素上调用String转型函数，然后比较字符串来决定顺序，即使数组的元素都是数值，也会将数组元素先转化为字符串在进行比较、排序。这就造成了排序不准确的情况，如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>];<br><span class="hljs-keyword">let</span> array2 = array.<span class="hljs-title function_">sort</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array2)  <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br><br><span class="hljs-keyword">let</span> array = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>];<br><span class="hljs-keyword">let</span> array2 = array.<span class="hljs-title function_">sort</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array2)  <span class="hljs-comment">//  [0, 1, 10, 15, 5]</span><br></code></pre></td></tr></table></figure><p>可以看到，上面第二段代码就出现了问题，虽然5是小于10的，但是字符串10在5的前面，所以10还是会排在5前面，因此可知，在很多情况下，不添加参数是不行的。</p><p>对于sort()方法的参数，它是一个比较函数，它接收两个参数，如果第一个参数应该排在第二个参数前面，就返回-1；如果两个参数相等，就返回0；如果第一个参数应该排在第二个参数后面，就返回1。一个比较函数的形式可以如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compare</span>(<span class="hljs-params">value1, value2</span>) &#123;<br><span class="hljs-keyword">if</span>(value1 &lt; value2)&#123;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(value1 &gt; value2)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>  &#125; <span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> array = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>];<br><span class="hljs-keyword">let</span> array2 = array.<span class="hljs-title function_">sort</span>(compare);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array2)  <span class="hljs-comment">// [0, 1, 5, 10, 15]</span><br></code></pre></td></tr></table></figure><p>我们使用箭头函数来定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>];<br><br><span class="hljs-keyword">let</span> array2 = array.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);  <span class="hljs-comment">// 正序排序</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array2)  <span class="hljs-comment">// [0, 1, 5, 10, 15]</span><br><br><span class="hljs-keyword">let</span> array3 = array.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a);  <span class="hljs-comment">// 倒序排序</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array3)  <span class="hljs-comment">// [15, 10, 5, 1, 0]</span><br></code></pre></td></tr></table></figure><h4 id="（2）reverse"><a href="#（2）reverse" class="headerlink" title="（2）reverse()"></a>（2）reverse()</h4><p>reverse() 方法用于颠倒数组中元素的顺序。该方法会改变原来的数组，而不会创建新的数组。其使用语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arrayObject.<span class="hljs-title function_">reverse</span>()<br></code></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> array2 = array.<span class="hljs-title function_">reverse</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array);   <span class="hljs-comment">// [5,4,3,2,1]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array2 === array);   <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="6-操作方法"><a href="#6-操作方法" class="headerlink" title="6. 操作方法"></a>6. 操作方法</h3><p>对于数组，还有很多操作方法，下面我们就来看看常用的concat()、slice()、splice()方法。</p><h4 id="（1）concat"><a href="#（1）concat" class="headerlink" title="（1）concat()"></a>（1）concat()</h4><p>concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。其适用语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arrayObject.<span class="hljs-title function_">concat</span>(arrayX,arrayX,......,arrayX)<br></code></pre></td></tr></table></figure><p>其中参数arrayX是必需的。该参数可以是具体的值，也可以是数组对象。可以是任意多个。</p><p>使用示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> array2 = array.<span class="hljs-title function_">concat</span>(<span class="hljs-number">4</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array2); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array);  <span class="hljs-comment">// [1, 2, 3], 可见原数组并未被修改</span><br></code></pre></td></tr></table></figure><p>该方法还可以用于数组扁平化，后面会介绍。</p><h4 id="（2）slice"><a href="#（2）slice" class="headerlink" title="（2）slice()"></a>（2）slice()</h4><p>slice() 方法可从已有的数组中返回选定的元素。返回一个新的数组，包含从 start 到 end （不包括该元素）的数组元素。方法并不会修改数组，而是返回一个子数组。其使用语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arrayObject.<span class="hljs-title function_">slice</span>(start,end)<br></code></pre></td></tr></table></figure><p>其参数如下：</p><ul><li><strong>start</strong>：必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推；</li><li><strong>end</strong>：可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</li></ul><p>使用示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>));    <span class="hljs-comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)); <span class="hljs-comment">// [&quot;three&quot;]</span><br></code></pre></td></tr></table></figure><h4 id="（3）splice"><a href="#（3）splice" class="headerlink" title="（3）splice()"></a>（3）splice()</h4><p>splice()方法可能是数组中的最强大的方法之一了，使用它的形式有很多种，它会向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组。其使用语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arrayObject.<span class="hljs-title function_">splice</span>(index, howmany, item1,.....,itemX)<br></code></pre></td></tr></table></figure><p>其参数如下：</p><ul><li>index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</li><li>howmany：必需。要删除的项目数量。如果设置为 0，则不会删除项目。</li><li>item1, …, itemX：可选。向数组添加的新项目。</li></ul><p>从上面参数可知，splice主要有三种使用形式：</p><ul><li><strong>删除：</strong>需要给splice()传递两个参数，即要删除的第一个元素的位置和要删除的元素的数量；</li><li><strong>插入：</strong>需要给splice()传递至少三个参数，即开始位置、0（要删除的元素数量）、要插入的元素。</li><li><strong>替换：</strong>splice()方法可以在删除元素的同事在指定位置插入新的元素。同样需要传入至少三个参数，即开始位置、要删除的元素数量、要插入的元素。要插入的元素数量是任意的，不一定和删除的元素数量相等。</li></ul><p>使用示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>,<span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));           <span class="hljs-comment">// 删除：[&quot;two&quot;, &quot;three&quot;]</span><br><br><span class="hljs-keyword">let</span> array = [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>,<span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">996</span>));      <span class="hljs-comment">// 插入：[]</span><br><br><span class="hljs-keyword">let</span> array = [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>,<span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">996</span>));      <span class="hljs-comment">// 替换：[&quot;three&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="7-归并方法"><a href="#7-归并方法" class="headerlink" title="7. 归并方法"></a>7. 归并方法</h3><p>ECMAScript为数组提供了两个归并方法：reduce()和reduceRight()。下面就分别来看看这两个方法。</p><h4 id="（1）reduce"><a href="#（1）reduce" class="headerlink" title="（1）reduce()"></a>（1）reduce()</h4><p>reduce() 方法对数组中的每个元素执行一个reducer函数(升序执行)，将其结果汇总为单个返回值。其使用语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.<span class="hljs-title function_">reduce</span>(callback,[initialValue])<br></code></pre></td></tr></table></figure><p>reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。<br>(1) <code>callback</code> （执行数组中每个值的函数，包含四个参数）</p><ul><li>previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））</li><li>currentValue （数组中当前被处理的元素）</li><li>index （当前元素在数组中的索引）</li><li>array （调用 reduce 的数组）</li></ul><p>(2) <code>initialValue</code> （作为第一次调用 callback 的第一个参数。）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">let</span> sum = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, cur, index, arr</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prev, cur, index);<br>    <span class="hljs-keyword">return</span> prev + cur;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr, sum);  <br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>再来加一个初始值看看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">let</span> sum = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, cur, index, arr</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prev, cur, index);<br>    <span class="hljs-keyword">return</span> prev + cur;<br>&#125;, <span class="hljs-number">5</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr, sum);  <br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-number">8</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">11</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>通过上面例子，可以得出结论：<strong>如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。</strong></p><p>注意，该方法如果添加初始值，就会改变原数组，将这个初始值放在数组的最后一位。</p><h4 id="（2）reduceRight"><a href="#（2）reduceRight" class="headerlink" title="（2）reduceRight()"></a>（2）reduceRight()</h4><p>该方法和的上面的<code>reduce()</code>用法几乎一致，只是该方法是对数组进行倒序查找的。而<code>reduce()</code>方法是正序执行的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">let</span> sum = arr.<span class="hljs-title function_">reduceRight</span>(<span class="hljs-function">(<span class="hljs-params">prev, cur, index, arr</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prev, cur, index);<br>    <span class="hljs-keyword">return</span> prev + cur;<br>&#125;, <span class="hljs-number">5</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr, sum);<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-number">9</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">12</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-number">14</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><h3 id="8-搜索和位置方法"><a href="#8-搜索和位置方法" class="headerlink" title="8. 搜索和位置方法"></a>8. 搜索和位置方法</h3><p>ECMAScript提供了两类搜索数组的方法：按照严格相等搜索和按照断言函数搜索。</p><h4 id="（1）严格相等"><a href="#（1）严格相等" class="headerlink" title="（1）严格相等"></a>（1）严格相等</h4><p>ECMAScript通过了3个严格相等的搜索方法：indexOf()、lastIndexOf()、includes()。这些方法都接收两个参数：要查找的元素和可选的其实搜索位置。lastIndexOf()方法会从数组结尾元素开始向前搜索，其他两个方法则会从数组开始元素向后进行搜索。indexOf()和lastIndexOf()返回的是查找元素在数组中的索引值，如果没有找到，则返回-1。includes()方法会返回布尔值，表示是否找到至少一个与指定元素匹配的项。在比较第一个参数和数组的每一项时，会使用全等（===）比较，也就是说两项必须严格相等。</p><p>使用示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">2</span>))      <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-number">3</span>))  <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">4</span>))     <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="（2）断言函数"><a href="#（2）断言函数" class="headerlink" title="（2）断言函数"></a>（2）断言函数</h4><p>ECMAScript也允许按照定义的断言函数搜索数组，每个索引都会调用这个函数，断言函数的返回值决定了相应索引的元素是否被认为匹配。使用断言函数的方法有两个，分别是find()和findIndex()方法。这两个方法对于空数组，函数是不会执行的。并且没有改变数组的原始值。他们的都有三个参数：元素、索引、元素所属的数组对象，其中元素是数组中当前搜索的元素，索引是当前元素的索引，而数组是当前正在搜索的数组。</p><p>这两个方法都从数组的开始进行搜索，find()返回的是第一个匹配的元素，如果没有符合条件的元素返回 undefined；findIndex()返回的是第一个匹配的元素的索引，如果没有符合条件的元素返回 -1。</p><p>使用示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>arr.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item &gt; <span class="hljs-number">2</span>)      <span class="hljs-comment">// 结果： 3</span><br>arr.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item &gt; <span class="hljs-number">2</span>) <span class="hljs-comment">// 结果： 2</span><br></code></pre></td></tr></table></figure><h3 id="9-迭代器方法"><a href="#9-迭代器方法" class="headerlink" title="9. 迭代器方法"></a>9. 迭代器方法</h3><p>在ES6中，Array的原型上暴露了3个用于检索数组内容的方法：keys()、values()、entries()。keys()方法返回数组索引的迭代器，values()方法返回数组元素的迭代器，entries()方法返回索引值对的迭代器。</p><p>使用示例如下（因为这些方法返回的都是迭代器，所以可以将他们的内容通过Array.from直接转化为数组实例）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(array.<span class="hljs-title function_">keys</span>()))     <span class="hljs-comment">// [0, 1, 2, 3, 4]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(array.<span class="hljs-title function_">values</span>()))   <span class="hljs-comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(array.<span class="hljs-title function_">entries</span>()))  <span class="hljs-comment">// [[0, &quot;one&quot;], [1, &quot;two&quot;], [2, &quot;three&quot;], [3, &quot;four&quot;], [4, &quot;five&quot;]]</span><br></code></pre></td></tr></table></figure><h3 id="10-迭代方法"><a href="#10-迭代方法" class="headerlink" title="10. 迭代方法"></a>10. 迭代方法</h3><p>ECMAScript为数组定义了5个迭代方法，分别是every()、filter()、forEach()、map()、some()。这些方法都不会改变原数组。这五个方法都接收两个参数：以每一项为参数运行的函数和可选的作为函数运行上下文的作用域对象（影响函数中的this值）。传给每个方法的函数接收三个参数，分别是当前元素、当前元素的索引值、当前元素所属的数对象。</p><h4 id="（1）forEach"><a href="#（1）forEach" class="headerlink" title="（1）forEach()"></a>（1）forEach()</h4><p><code>forEach</code> 方法用于调用数组的每个元素，并将元素传递给回调函数。该方法没有返回值，使用示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index, arr</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index+<span class="hljs-string">&quot;:&quot;</span>+item)<br>&#125;)<br></code></pre></td></tr></table></figure><p>该方法还可以有第二个参数，用来绑定回调函数内部this变量（回调函数不能是箭头函数，因为箭头函数没有this）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>]<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, arr</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>[index])  <span class="hljs-comment">//  9 8 7 6 5</span><br>&#125;, arr1)<br></code></pre></td></tr></table></figure><h4 id="（2）map"><a href="#（2）map" class="headerlink" title="（2）map()"></a>（2）map()</h4><p><code>map()</code> 方法会返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。该方法按照原始数组元素顺序依次处理元素。该方法不会对空数组进行检测，它会返回一个新数组，<strong>不会改变原始数组</strong>。使用示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br> <br>arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> item+<span class="hljs-number">1</span>;<br>&#125;)<br><span class="hljs-comment">// 结果： [2, 3, 4]</span><br></code></pre></td></tr></table></figure><p>第二个参数用来绑定参数函数内部的this变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br> <br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[e];<br>&#125;, arr)<br> <span class="hljs-comment">// 结果： [&#x27;b&#x27;, &#x27;c&#x27;]</span><br></code></pre></td></tr></table></figure><p>该方法可以进行链式调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br> <br>arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item+<span class="hljs-number">1</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item+<span class="hljs-number">1</span>)<br> <span class="hljs-comment">// 结果： [3, 4, 5]</span><br></code></pre></td></tr></table></figure><p><strong>forEach和map区别如下：</strong></p><ul><li><p>forEach()方法：会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；</p></li><li><p>map()方法：不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</p><h4 id="（3）filter"><a href="#（3）filter" class="headerlink" title="（3）filter()"></a>（3）filter()</h4><p><code>filter()</code>方法用于过滤数组，满足条件的元素会被返回。它的参数是一个回调函数，所有数组元素依次执行该函数，返回结果为true的元素会被返回。该方法会返回一个新的数组，不会改变原数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item &gt; <span class="hljs-number">2</span>) <br><span class="hljs-comment">// 结果：[3, 4, 5]</span><br></code></pre></td></tr></table></figure><p>可以使用<code>filter()</code>方法来移除数组中的undefined、null、NAN等值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">3</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>]<br>arr.<span class="hljs-title function_">filter</span>(<span class="hljs-title class_">Boolean</span>)<br><span class="hljs-comment">// 结果：[1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><h4 id="（4）every"><a href="#（4）every" class="headerlink" title="（4）every()"></a>（4）every()</h4><p>该方法会对数组中的每一项进行遍历，只有所有元素都符合条件时，才返回true，否则就返回false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>arr.<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item &gt; <span class="hljs-number">0</span>) <br><span class="hljs-comment">// 结果： true</span><br></code></pre></td></tr></table></figure><h4 id="（5）some"><a href="#（5）some" class="headerlink" title="（5）some()"></a>（5）some()</h4><p>该方法会对数组中的每一项进行遍历，只要有一个元素符合条件，就返回true，否则就返回false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>arr.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item &gt; <span class="hljs-number">4</span>) <br><span class="hljs-comment">// 结果： true</span><br></code></pre></td></tr></table></figure><h3 id="11-其他方法"><a href="#11-其他方法" class="headerlink" title="11. 其他方法"></a>11. 其他方法</h3><p>除了上述方法，遍历数组的方法还有for…in和for…of。下面就来简单看一下。</p><h4 id="（1）for…in"><a href="#（1）for…in" class="headerlink" title="（1）for…in"></a>（1）for…in</h4><p><code>for…in</code> 主要用于对数组或者对象的属性进行循环操作。循环中的代码每执行一次，就会对对象的属性进行一次操作。其使用语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> object) &#123;<br>  执行的代码块<br>&#125;<br></code></pre></td></tr></table></figure><p>其中两个参数：</p></li><li><p>item：必须。指定的变量可以是数组元素，也可以是对象的属性。</p></li><li><p>object：必须。指定迭代的的对象。</p></li></ul><p>使用示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <br> <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> arr) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;键名：&#x27;</span>, i); <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;键值：&#x27;</span>, arr[i]); <br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">键名： <span class="hljs-number">0</span><br>键值： <span class="hljs-number">1</span><br>键名： <span class="hljs-number">1</span><br>键值： <span class="hljs-number">2</span><br>键名： <span class="hljs-number">2</span><br>键值： <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>需要注意，该方法<strong>不仅会遍历当前的对象所有的可枚举属性，还会遍历其原型链上的属性。</strong>除此之外，该方法遍历数组时候，遍历出来的是数组的索引值，遍历对象的时候，遍历出来的是键值名。</p><h4 id="（2）for…of"><a href="#（2）for…of" class="headerlink" title="（2）for…of"></a>（2）for…of</h4><p><code>for...of</code> 语句创建一个循环来迭代可迭代的对象。在 ES6 中引入的 <code>for...of</code> 循环，以替代 <code>for...in</code> 和 <code>forEach()</code> ，并支持新的迭代协议。<code>for...of</code> 允许遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代的数据结构等。</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">of</span> iterable) &#123;<br>    执行的代码块<br>&#125;<br></code></pre></td></tr></table></figure><p>其中两个参数：</p><ul><li>item：每个迭代的属性值被分配给该变量。</li><li>iterable：一个具有可枚举属性并且可以迭代的对象。</li></ul><p>该方法允许获取对象的键值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a <span class="hljs-keyword">in</span> arr) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 0 1 2 3</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a <span class="hljs-keyword">of</span> arr) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// a b c d</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该方法只会遍历当前对象的属性，不会遍历其原型链上的属性。</p><p><strong>注意：</strong></p><ul><li>for…of适用遍历 <strong>数组/ 类数组/字符串/map/set</strong> 等拥有迭代器对象的集合；</li><li>它可以正确响应break、continue和return语句；</li><li>for…of循环不支持遍历普通对象，因为没有迭代器对象。如果想要遍历一个对象的属性，可以用<code>for-in</code>循环。</li></ul><p><strong>总结，for…of 和for…in的区别如下：</strong></p><ul><li>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；</li><li>for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；</li><li>对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；<h4 id="（3）flat"><a href="#（3）flat" class="headerlink" title="（3）flat()"></a>（3）flat()</h4>在ES2019中，flat()方法用于创建并返回一个新数组，这个新数组包含与它调用flat()的数组相同的元素，只不过其中任何本身也是数组的元素会被打平填充到返回的数组中：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]].<span class="hljs-title function_">flat</span>()   <span class="hljs-comment">// [1, 2, 3]</span><br>[<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]].<span class="hljs-title function_">flat</span>()   <span class="hljs-comment">// [1, 2, [3, 4]]</span><br></code></pre></td></tr></table></figure>在不传参数时，flat()默认只会打平一级嵌套，如果想要打平更多的层级，就需要传给flat()一个数值参数，这个参数表示要打平的层级数：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]].<span class="hljs-title function_">flat</span>(<span class="hljs-number">2</span>)   <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><h2 id="三、类数组对象"><a href="#三、类数组对象" class="headerlink" title="三、类数组对象"></a>三、类数组对象</h2>JavaScript 中一直存在一种类数组的对象，它们不能直接调用数组的方法，但是又和数组比较类似，在某些特定的编程场景中会出现，下面就来看一下什么是类数组。</li></ul><p>在 JavaScript 中，主要有以下情况中的对象是类数组：</p><ul><li>函数里面的参数对象 arguments；</li><li>用 getElementsByTagName/ClassName/Name 获得的 HTMLCollection；</li><li>用 querySelector 获得的 NodeList。<h3 id="1-类数组概述"><a href="#1-类数组概述" class="headerlink" title="1. 类数组概述"></a>1. 类数组概述</h3><h4 id="（1）arguments"><a href="#（1）arguments" class="headerlink" title="（1）arguments"></a>（1）arguments</h4>在日常开发中经常会遇到各种类数组对象，最常见的就是在函数中使用的 arguments，它的对象只定义在函数体中，包括了函数的参数和其他属性。先来看下 arguments 的使用方法：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">name, age, sex</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">arguments</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>));<br>&#125;<br><span class="hljs-title function_">foo</span>(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-string">&#x27;18&#x27;</span>, <span class="hljs-string">&#x27;male&#x27;</span>);<br></code></pre></td></tr></table></figure>打印结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1612679309803-e5208c79-c41f-4dce-87a7-6b8f16f5afc8.png#height=169&id=ol1vU&margin=%5Bobject%20Object%5D&name=image.png&originHeight=174&originWidth=686&originalType=binary&ratio=1&size=18821&status=done&style=shadow&width=666" alt="image.png"><br>可以看到，typeof 这个 arguments 返回的是 object，通过 Object.prototype.toString.call 返回的结果是 [object arguments]，而不是 [object array]，说明 arguments 和数组还是有区别的。</li></ul><p>length 属性就是函数参数的长度。另外 arguments 还有一个 callee 属性，下面看看这个 callee 是干什么的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">name, age, sex</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">callee</span>);<br>&#125;<br><br><span class="hljs-title function_">foo</span>(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-string">&#x27;18&#x27;</span>, <span class="hljs-string">&#x27;male&#x27;</span>);<br></code></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ƒ <span class="hljs-title function_">foo</span>(<span class="hljs-params">name, age, sex</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">callee</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，输出的就是函数自身，如果在函数内部直接执行调用 callee，那它就会不停地执行当前函数，直到执行到内存溢出。</p><h4 id="（2）HTMLCollection"><a href="#（2）HTMLCollection" class="headerlink" title="（2）HTMLCollection"></a>（2）HTMLCollection</h4><p>HTMLCollection 简单来说是 HTML DOM 对象的一个接口，这个接口包含了获取到的 DOM 元素集合，返回的类型是类数组对象，如果用 typeof 来判断的话，它返回的是 object。它是及时更新的，当文档中的 DOM 变化时，它也会随之变化。</p><p>下面来 HTMLCollection 最后返回的是什么，在一个<strong>有 form 表单</strong>的页面中，在控制台中执行下述代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> elem1, elem2;<br><span class="hljs-comment">// document.forms 是一个 HTMLCollection</span><br>elem1 = <span class="hljs-variable language_">document</span>.<span class="hljs-property">forms</span>[<span class="hljs-number">0</span>];<br>elem2 = <span class="hljs-variable language_">document</span>.<span class="hljs-property">forms</span>.<span class="hljs-title function_">item</span>(<span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(elem1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(elem2);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> elem1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(elem1));<br></code></pre></td></tr></table></figure><p>打印结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1612679850622-ec390549-4b7a-49d2-ab58-45156d86d33c.png#height=116&id=LSXFQ&margin=%5Bobject%20Object%5D&name=image.png&originHeight=116&originWidth=599&originalType=binary&ratio=1&size=32190&status=done&style=shadow&width=599" alt="image.png"><br>可以看到，这里打印出来了页面第一个 form 表单元素，同时也打印出来了判断类型的结果，说明打印的判断的类型和 arguments 返回的也比较类似，typeof 返回的都是 object，和上面的类似。</p><p>注意：HTML DOM 中的 HTMLCollection 是即时更新的，当其所包含的文档结构发生改变时，它会自动更新。</p><h4 id="（3）NodeList"><a href="#（3）NodeList" class="headerlink" title="（3）NodeList"></a>（3）NodeList</h4><p>NodeList 对象是节点的集合，通常是由 querySlector 返回的。NodeList 不是一个数组，也是一种类数组。虽然 NodeList 不是一个数组，但是可以使用 for…of 来迭代。在一些情况下，NodeList 是一个实时集合，也就是说，如果文档中的节点树发生变化，NodeList 也会随之变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;input[type=checkbox]&#x27;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> checkbox <span class="hljs-keyword">of</span> list) &#123;<br>  checkbox.<span class="hljs-property">checked</span> = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> list);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(list));<br></code></pre></td></tr></table></figure><p>打印结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1612680061951-5c2803a4-8d30-49c9-b50f-a1147d4d4274.png#height=208&id=TktkX&margin=%5Bobject%20Object%5D&name=image.png&originHeight=208&originWidth=608&originalType=binary&ratio=1&size=37151&status=done&style=shadow&width=608" alt="image.png"></p><h3 id="2-类数组应用场景"><a href="#2-类数组应用场景" class="headerlink" title="2. 类数组应用场景"></a>2. 类数组应用场景</h3><h4 id="（1）遍历参数操作"><a href="#（1）遍历参数操作" class="headerlink" title="（1）遍历参数操作"></a>（1）遍历参数操作</h4><p>在函数内部可以直接获取 arguments 这个类数组的值，那么也可以对于参数进行一些操作，比如下面这段代码可以将函数的参数默认进行求和操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> sum =<span class="hljs-number">0</span>,<br>        len = <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>        sum += <span class="hljs-variable language_">arguments</span>[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-title function_">add</span>()                            <span class="hljs-comment">// 0</span><br><span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>)                           <span class="hljs-comment">// 1</span><br><span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>，<span class="hljs-number">2</span>)                        <span class="hljs-comment">// 3</span><br><span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);                    <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p>结合上面这段代码，在函数内部可以将参数直接进行累加操作，以达到预期的效果，参数多少也可以不受限制，根据长度直接计算，返回出最后函数的参数的累加结果，其他操作也类似。</p><h4 id="（2）定义连接字符串函数"><a href="#（2）定义连接字符串函数" class="headerlink" title="（2）定义连接字符串函数"></a>（2）定义连接字符串函数</h4><p>可以通过 arguments 这个例子定义一个函数来连接字符串。这个函数唯一正式声明了的参数是一个字符串，该参数指定一个字符作为衔接点来连接字符串。该函数定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myConcat</span>(<span class="hljs-params">separa</span>) &#123;<br>  <span class="hljs-keyword">var</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> args.<span class="hljs-title function_">join</span>(separa);<br>&#125;<br><span class="hljs-title function_">myConcat</span>(<span class="hljs-string">&quot;, &quot;</span>, <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>);<br><span class="hljs-comment">// &quot;red, orange, blue&quot;</span><br><span class="hljs-title function_">myConcat</span>(<span class="hljs-string">&quot;; &quot;</span>, <span class="hljs-string">&quot;elephant&quot;</span>, <span class="hljs-string">&quot;lion&quot;</span>, <span class="hljs-string">&quot;snake&quot;</span>);<br><span class="hljs-comment">// &quot;elephant; lion; snake&quot;</span><br><span class="hljs-title function_">myConcat</span>(<span class="hljs-string">&quot;. &quot;</span>, <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>);<br><span class="hljs-comment">// &quot;one. two. three. four. five&quot;</span><br></code></pre></td></tr></table></figure><p>这段代码说明可以传递任意数量的参数到该函数，并使用每个参数作为列表中的项创建列表进行拼接。从这个例子中也可以看出，可以在日常编码中采用这样的代码抽象方式，把需要解决的这一类问题，都抽象成通用的方法，来提升代码的可复用性。</p><h4 id="（3）传递参数"><a href="#（3）传递参数" class="headerlink" title="（3）传递参数"></a>（3）传递参数</h4><p>可以借助apply 或 call 与 arguments 相结合，将参数从一个函数传递到另一个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.</span> <span class="hljs-comment">// 使用 apply 将 foo 的参数传递给 bar</span><br><span class="hljs-number">2.</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-number">3.</span>     bar.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br><span class="hljs-number">4.</span> &#125;<br><span class="hljs-number">5.</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">a, b, c</span>) &#123;<br><span class="hljs-number">6.</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b, c);<br><span class="hljs-number">7.</span> &#125;<br><span class="hljs-number">8.</span> <span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)   <span class="hljs-comment">//1 2 3</span><br></code></pre></td></tr></table></figure><p>上述代码中，通过在 foo 函数内部调用 apply 方法，用 foo 函数的参数传递给 bar 函数，这样就实现了借用参数的妙用。</p><h3 id="3-类数组转为数组"><a href="#3-类数组转为数组" class="headerlink" title="3. 类数组转为数组"></a>3. 类数组转为数组</h3><h4 id="（1）借用数组方法"><a href="#（1）借用数组方法" class="headerlink" title="（1）借用数组方法"></a>（1）借用数组方法</h4><p>类数组因为不是真正的数组，所以没有数组类型上自带的那些方法，所以就需要利用下面这几个方法去借用数组的方法。比如借用数组的 push 方法，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arrayLike = &#123; <br>  <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;java&#x27;</span>,<br>  <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;script&#x27;</span>,<br>  <span class="hljs-attr">length</span>: <span class="hljs-number">2</span><br>&#125; <br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">push</span>.<span class="hljs-title function_">call</span>(arrayLike, <span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-string">&#x27;lily&#x27;</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> arrayLike); <span class="hljs-comment">// &#x27;object&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrayLike);<br><span class="hljs-comment">// &#123;0: &quot;java&quot;, 1: &quot;script&quot;, 2: &quot;jack&quot;, 3: &quot;lily&quot;, length: 4&#125;</span><br></code></pre></td></tr></table></figure><p>可以看到，arrayLike 其实是一个对象，模拟数组的一个类数组，从数据类型上说它是一个对象，新增了一个 length 的属性。还可以看出，用 typeof 来判断输出的是 object，它自身是不会有数组的 push 方法的，这里用 call 的方法来借用 Array 原型链上的 push 方法，可以实现一个类数组的 push 方法，给 arrayLike 添加新的元素。</p><p>从打印结果可以看出，数组的 push 方法满足了我们想要实现添加元素的诉求。再来看下 arguments 如何转换成数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">let</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br> <span class="hljs-comment">// let args = [].slice.call(arguments); // 这样写也是一样效果</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, cur</span>) =&gt;</span> sum + cur));<br>&#125;<br><span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">let</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">concat</span>.<span class="hljs-title function_">apply</span>([], <span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, cur</span>) =&gt;</span> sum + cur));<br>&#125;<br><span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>可以看到，借用 Array 原型链上的各种方法，来实现 sum 函数的参数相加的效果。一开始都是将 arguments 通过借用数组的方法转换为真正的数组，最后都又通过数组的 reduce 方法实现了参数转化的真数组 args 的相加，最后返回预期的结果。</p><h4 id="（2）借用ES6方法"><a href="#（2）借用ES6方法" class="headerlink" title="（2）借用ES6方法"></a>（2）借用ES6方法</h4><p>还可以采用 ES6 新增的 Array.from 方法以及展开运算符的方法来将类数组转化为数组。那么还是围绕上面这个 sum 函数来进行改变，看下用 Array.from 和展开运算符是怎么实现转换数组的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">let</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, cur</span>) =&gt;</span> sum + cur));<br>&#125;<br><span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);    <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>];<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, cur</span>) =&gt;</span> sum + cur));<br>&#125;<br><span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);    <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">...args</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, cur</span>) =&gt;</span> sum + cur));<br>&#125;<br><span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);    <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>可以看到，Array.from 和 ES6 的展开运算符，都可以把 arguments 这个类数组转换成数组 args，从而实现调用 reduce 方法对参数进行累加操作。其中第二种和第三种都是用 ES6 的展开运算符，虽然写法不一样，但是基本都可以满足多个参数实现累加的效果。</p><h2 id="四、数组常见操作"><a href="#四、数组常见操作" class="headerlink" title="四、数组常见操作"></a>四、数组常见操作</h2><h3 id="1-数组扁平化"><a href="#1-数组扁平化" class="headerlink" title="1. 数组扁平化"></a>1. 数组扁平化</h3><p>下面再来看看数组的扁平化。所谓扁平化，其实就是将一个嵌套多层的数组 array（嵌套可以是任何层数）转换为只有一层的数组。举个简单的例子，假设有个名为 flatten 的函数可以做到数组扁平化，那么输出效果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>，<span class="hljs-number">5</span>]]];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flatten</span>(arr));  <span class="hljs-comment">// [1, 2, 3, 4，5]</span><br></code></pre></td></tr></table></figure><p>简单来说就是把多维的数组“拍平”，输出最后的一维数组。下面来看看实现flatten函数的方式。</p><h4 id="（1）递归实现"><a href="#（1）递归实现" class="headerlink" title="（1）递归实现"></a>（1）递归实现</h4><p>普通的递归思路很容易理解，就是通过循环递归的方式，一项一项地去遍历，如果某一项还是一个数组，那么就继续往下遍历，利用递归来实现数组的每一项的连接：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = [];<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr[i])) &#123;<br>      result = result.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">flatten</span>(arr[i]));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result.<span class="hljs-title function_">push</span>(arr[i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-title function_">flatten</span>(arr);  <span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br></code></pre></td></tr></table></figure><p>可以看到，最后返回的结果是扁平化的结果，这段代码核心就是循环遍历过程中的递归操作，就是在遍历过程中发现数组元素还是数组的时候进行递归操作，把数组的结果通过数组的 concat 方法拼接到最后要返回的 result 数组上，那么最后输出的结果就是扁平化后的数组。</p><h4 id="（2）reduce-函数迭代"><a href="#（2）reduce-函数迭代" class="headerlink" title="（2）reduce 函数迭代"></a>（2）reduce 函数迭代</h4><p>从上面的递归函数可以看出，其实就是对数组的每一项进行处理，那么其实也可以用 reduce 来实现数组的拼接，从而简化上面方法的代码，改造后的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">prev, next</span>)&#123;<br>        <span class="hljs-keyword">return</span> prev.<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(next) ? <span class="hljs-title function_">flatten</span>(next) : next)<br>    &#125;, [])<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flatten</span>(arr));<span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br></code></pre></td></tr></table></figure><p>这段代码在控制台执行之后，也可以得到想要的结果。上面我们说了 reduce 的第一个参数用来返回最后累加的结果，思路和第一种递归方法是一样的，但是通过使用 reduce 之后代码变得更简洁了，也同样解决了扁平化的问题。</p><h4 id="（3）扩展运算符实现"><a href="#（3）扩展运算符实现" class="headerlink" title="（3）扩展运算符实现"></a>（3）扩展运算符实现</h4><p>这个方法的实现，采用了扩展运算符和 some 的方法，两者共同使用，达到数组扁平化的目的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">while</span> (arr.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item))) &#123;<br>        arr = [].<span class="hljs-title function_">concat</span>(...arr);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flatten</span>(arr)); <span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br></code></pre></td></tr></table></figure><p>从执行的结果中可以发现，先用数组的 some 方法把数组中仍然是组数的项过滤出来，然后执行 concat 操作，利用 ES6 的展开运算符，将其拼接到原数组中，最后返回原数组，达到了预期的效果。</p><h4 id="（4）split-和-toString"><a href="#（4）split-和-toString" class="headerlink" title="（4）split 和 toString"></a>（4）split 和 toString</h4><p>可以通过 split 和 toString 两个方法来共同实现数组扁平化，由于数组会默认带一个 toString 的方法，所以可以把数组直接转换成逗号分隔的字符串，然后再用 split 方法把字符串重新转换为数组，如下面的代码所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flatten</span>(arr)); <span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br></code></pre></td></tr></table></figure><p>通过这两个方法可以将多维数组直接转换成逗号连接的字符串，然后再重新分隔成数组。</p><h4 id="（5）ES6-中的-flat"><a href="#（5）ES6-中的-flat" class="headerlink" title="（5）ES6 中的 flat"></a>（5）ES6 中的 flat</h4><p>我们还可以直接调用 ES6 中的 flat 方法来实现数组扁平化。flat 方法的语法：<code>arr.flat([depth])</code></p><p>其中 depth 是 flat 的参数，depth 是可以传递数组的展开深度（默认不填、数值是 1），即展开一层数组。如果层数不确定，参数可以传进 Infinity，代表不论多少层都要展开：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">flat</span>(<span class="hljs-title class_">Infinity</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flatten</span>(arr)); <span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br></code></pre></td></tr></table></figure><p>可以看出，一个嵌套了两层的数组，通过将 flat 方法的参数设置为 Infinity，达到了我们预期的效果。其实同样也可以设置成 2，也能实现这样的效果。在编程过程中，如果数组的嵌套层数不确定，最好直接使用 Infinity，可以达到扁平化的效果。</p><h4 id="（6）正则和-JSON-方法"><a href="#（6）正则和-JSON-方法" class="headerlink" title="（6）正则和 JSON 方法"></a>（6）正则和 JSON 方法</h4><p>在第4种方法中已经使用 toString 方法，其中仍然采用了将 JSON.stringify 的方法先转换为字符串，然后通过正则表达式过滤掉字符串中的数组的方括号，最后再利用 JSON.parse 把它转换成数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]], <span class="hljs-number">6</span>];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">let</span> str = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(arr);<br>  str = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(\[|\])/g</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>  str = <span class="hljs-string">&#x27;[&#x27;</span> + str + <span class="hljs-string">&#x27;]&#x27;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str); <br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flatten</span>(arr)); <span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br></code></pre></td></tr></table></figure><p>可以看到，其中先把传入的数组转换成字符串，然后通过正则表达式的方式把括号过滤掉，匹配规则是：全局匹配（g）左括号或者右括号，将它们替换成空格，最后返回处理后的结果。之后拿着正则处理好的结果重新在外层包裹括号，最后通过 JSON.parse 转换成数组返回。</p><h3 id="2-数组去重"><a href="#2-数组去重" class="headerlink" title="2. 数组去重"></a>2. 数组去重</h3><p>去除无序数组中的重复元素并且返回新的无重复数组。</p><h4 id="（1）Set实现"><a href="#（1）Set实现" class="headerlink" title="（1）Set实现"></a>（1）Set实现</h4><p>ES6方法（使用数据结构集合）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>];<br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(array)); <span class="hljs-comment">// [1, 2, 3, 5, 9, 8]</span><br></code></pre></td></tr></table></figure><h4 id="（2）map实现"><a href="#（2）map实现" class="headerlink" title="（2）map实现"></a>（2）map实现</h4><p>ES5方法：使用map存储不重复的数字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>];<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueArray</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">let</span> map = &#123;&#125;;<br>  <span class="hljs-keyword">let</span> res = [];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span>(!map.<span class="hljs-title function_">hasOwnProperty</span>([array[i]])) &#123;<br>      map[array[i]] = <span class="hljs-number">1</span>;<br>      res.<span class="hljs-title function_">push</span>(array[i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-title function_">uniqueArray</span>(array); <span class="hljs-comment">// [1, 2, 3, 5, 9, 8]</span><br></code></pre></td></tr></table></figure><h3 id="3-数组求和"><a href="#3-数组求和" class="headerlink" title="3. 数组求和"></a>3. 数组求和</h3><h4 id="（1）reduce实现"><a href="#（1）reduce实现" class="headerlink" title="（1）reduce实现"></a>（1）reduce实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br><span class="hljs-keyword">let</span> sum = arr.<span class="hljs-title function_">reduce</span>( <span class="hljs-function">(<span class="hljs-params">total,i</span>) =&gt;</span> total += i,<span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum);     <span class="hljs-comment">// 21</span><br></code></pre></td></tr></table></figure><h4 id="（2）递归实现"><a href="#（2）递归实现" class="headerlink" title="（2）递归实现"></a>（2）递归实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>] <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>] <br>    <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>] + <span class="hljs-title function_">add</span>(arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)) <br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(arr))  <span class="hljs-comment">// 21</span><br></code></pre></td></tr></table></figure><h3 id="4-数组乱序"><a href="#4-数组乱序" class="headerlink" title="4. 数组乱序"></a>4. 数组乱序</h3><h4 id="（1）正向遍历"><a href="#（1）正向遍历" class="headerlink" title="（1）正向遍历"></a>（1）正向遍历</h4><p>主要的实现思路就是：</p><ol><li>取出数组的第一个元素，随机产生一个索引值，将该第一个元素和这个索引对应的元素进行交换；</li><li>第二次取出数据数组第二个元素，随机产生一个除了索引为1的之外的索引值，并将第二个元素与该索引值对应的元素进行交换；</li><li>按照上面的规律执行，直到遍历完成。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-keyword">const</span> randomIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> - i)) + i;<br>  [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<br></code></pre></td></tr></table></figure><h4 id="（2）倒序遍历"><a href="#（2）倒序遍历" class="headerlink" title="（2）倒序遍历"></a>（2）倒序遍历</h4>倒序遍历和上面实现思路类似，代码如下：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>];<br><span class="hljs-keyword">let</span> length = arr.<span class="hljs-property">length</span>,<br>    randomIndex,<br>    temp;<br>  <span class="hljs-keyword">while</span> (length) &#123;<br>    randomIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * length--);<br>    temp = arr[length];<br>    arr[length] = arr[randomIndex];<br>    arr[randomIndex] = temp;<br>  &#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式概述（一）</title>
    <link href="/luok_blog/2022/09/13/01%20CS/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/a.%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"/>
    <url>/luok_blog/2022/09/13/01%20CS/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/a.%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><ul><li>Context（模式可适用的前提条件）</li><li>Theme或Problem（在特定条件下要解决的目标问题）</li><li>Solution（对目标问题求解过程中各种物理关系的记述）<br>经典定义：<br>模式是在<strong>特定环境下</strong>人们解决某类重复出现<strong>问题</strong>的一套成功或有效的<strong>解决方案</strong>。</li></ul><p>设计模式(Design Pattern)</p><ul><li>一套被<strong>反复使用的、多数人知晓的、经过分类编目的、代码设计经验的</strong>总结</li><li>是一种用于对软件系统中不断重现的设计问题的<strong>解决方案</strong>进行<strong>文档化</strong>的技术<br>是一种<strong>共享</strong>专家设计经验的技术</li><li>目的：为了可重用代码、让代码更容易被他人理解、提高代码可靠性</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式是在<strong>特定环境下为</strong>解决<strong>某一通用软件设计</strong>问题提供的一套<strong>定制的解决方案</strong>，该方案描述了对象和类之间的相互作用。</p><p>基本要素</p><ul><li><strong>模式名称</strong> (Pattern Name) </li><li><strong>问题</strong> (Problem) </li><li><strong>解决方案</strong> (Solution) </li><li><strong>效果</strong> (Consequences) </li></ul><p>分类<br>根据目的</p><ul><li>创建型模式(Creational)主要用于<strong>创建对象</strong></li><li>结构型模式(Structural)主要用于<strong>处理类或对象的组合</strong></li><li>行为型模式(Behavioral)主要用于<strong>描述类或对象如何交互和怎样分配职责</strong><br>根据范围</li><li>类模式处理<strong>类和子类之间的关系</strong>，这些关系通过继承建立，在编译时刻就被确定下来，是一种<strong>静态</strong>关系</li><li>对象模式处理<strong>对象间的关系</strong>，这些关系在运行时变化，更具<strong>动态</strong>性</li></ul><p><img src="https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20220929112441.png"></p><p>优点</p><ul><li>融合了众多专家的经验，并以一种标准的形式供广大开发人员所用</li><li>提供了一套通用的设计词汇和一种通用的语言，以方便开发人员之间进行沟通和交流，使得设计方案更加通俗易懂</li><li>让人们可以更加简单方便地复用成功的设计和体系结构</li><li>使得设计方案更加灵活，且易于修改</li><li>将提高软件系统的开发效率和软件质量，且在一定程度上节约设计成本</li><li>有助于初学者更深入地理解面向对象思想，方便阅读和学习现有类库与其他系统中的源代码，还可以提高软件的设计水平和代码质量</li></ul><h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><p><a href="http://www.cs.utsa.edu/~cs3443/notes/designPrinciples/designPrinciples.html">Principles of Object-Oriented Design</a></p><p>面向对象设计原则为支持<strong>可维护性复用</strong>而诞生,<strong>指导性原则</strong>而非强制性原则，用于评价一个设计模式的使用效果的重要指标之一。</p><ul><li>可维护性(Maintainability)：指软件能够被理解、改正、适应及扩展的难易程度</li><li>可复用性(Reusability)：指软件能够被重复使用的难易程度</li></ul><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><blockquote><p><em><strong>一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。</strong></em></p></blockquote><p>单一职责原则是最简单的面向对象设计原则，用于<strong>控制类的粒度大小</strong>,就一个类而言，应该仅有<strong>一个引起它变化的原因</strong></p><p>分析</p><ul><li>一个类（大到模块，小到方法）<strong>承担的职责越多</strong>，它<strong>被复用的可能性就越小</strong></li><li><strong>当一个职责变化时</strong>，可能<strong>会影响其他职责的运作</strong></li><li>将这些职责进行分离，<strong>将不同的职责封装在不同的类中</strong></li><li>将不同的变化原因封装在不同的类中</li><li>单一职责原则是<strong>实现高内聚、低耦合的指导方针</strong></li></ul><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><blockquote><p><em><strong>软件实体应当对扩展开放，对修改关闭。</strong></em></p></blockquote><p>开闭原则是面向对象的<strong>可复用设计的第一块基石</strong>，是<strong>最重要</strong>的面向对象设计原则</p><p>分析<br>在开闭原则的定义中，软件实体可以是一个软件模块、一个由多个类组成的局部结构或一个独立的类<br>开闭原则是指软件实体应<strong>尽量在不修改原有代码的情况下进行扩展</strong><br><strong>抽象化</strong>是开闭原则的关键<br>相对稳定的<strong>抽象层</strong> + 灵活的<strong>具体层</strong><br>对可变性封装原则(Principle of Encapsulation of Variation, EVP)：找到系统的可变因素并将其封装起来</p><h3 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h3><blockquote><p><strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>。</p></blockquote><p>分析</p><ul><li>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象</li><li>在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型</li></ul><h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><blockquote><p>高层模块不应该依赖低层模块，它们都应该依赖抽象。<strong>抽象不应该依赖于细节，细节应该依赖于抽象。</strong></p></blockquote><p>要针对接口编程，不要针对实现编程.<br>分析</p><ul><li>在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等</li><li>在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中</li><li>针对抽象层编程，将具体类的对象通过依赖注入(Dependency Injection, DI)的方式注入到其他对象</li></ul><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><blockquote><p><strong>客户端不应该依赖那些它不需要的接口。</strong></p></blockquote><p>分析</p><ul><li>当一个接口太大时，需要将它分割成一些<strong>更细小</strong>的接口</li><li>使用该接口的客户端<strong>仅需知道与之相关的方法</strong>即可</li><li>每一个接口应该<strong>承担一种相对独立的角色</strong>，不干不该干的事，该干的事都要干</li></ul><h3 id="合成复用原则-组合-聚合复用原则"><a href="#合成复用原则-组合-聚合复用原则" class="headerlink" title="合成复用原则(组合/聚合复用原则)"></a>合成复用原则(组合/聚合复用原则)</h3><blockquote><p><strong>优先使用对象组合，而不是继承来达到复用的目的。</strong></p></blockquote><p>分析</p><ul><li>合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分</li><li>新对象通过委派调用已有对象的方法达到复用功能的目的</li><li>复用时要尽量使用组合/聚合关系（关联关系），少用继承</li><li>继承复用：实现简单，易于扩展。破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（“白箱”复用 ）</li><li>组合/聚合复用：耦合度相对较低，有选择性地调用成员对象的操作；可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。（“黑箱”复用 ）</li></ul><h3 id="迪米特法则-最少知识原则"><a href="#迪米特法则-最少知识原则" class="headerlink" title="迪米特法则(最少知识原则)"></a>迪米特法则(最少知识原则)</h3><blockquote><p>每一个软件单位对其他的单位都只有<strong>最少的知识</strong>，而且<strong>局限于那些与本单位密切相关的软件单位</strong>。</p></blockquote><p>分析</p><ul><li>迪米特法则要求<strong>一个软件实体应当尽可能少地与其他实体发生相互作用</strong></li><li>应用迪米特法则可<strong>降低系统的耦合度</strong>，使类与类之间保持松散的耦合关系</li><li>迪米特法则要求在设计系统时，应该尽量减少对象之间的交互</li><li>如果两个对象之间不必彼此直接通信，那么这两个对象就不应该发生任何直接的相互作用</li><li>如果其中一个对象需要调用另一个对象的方法，可以通过“第三者”转发这个调用</li><li>通过引入一个合理的“第三者”来降低现有对象之间的耦合度</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
      <tag>考试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第四章 指令设计</title>
    <link href="/luok_blog/2022/07/13/01%20CS/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E8%AE%BE%E8%AE%A1/"/>
    <url>/luok_blog/2022/07/13/01%20CS/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="1-1指令的定义"><a href="#1-1指令的定义" class="headerlink" title="1.1指令的定义"></a>1.1指令的定义</h2><p>指令(又称机器指令):</p><ul><li>是指示计算机执行某种操作的命令，是计算机运行的<strong>最小功能单位</strong>。</li><li>一台计算机的所有指令的<strong>集合</strong>构成该机的<strong>指令系统</strong>，也称为<strong>指令集</strong>。<br>注:一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。<br>Eg: x86架构、ARM架构</li></ul><h2 id="1-2指令的格式"><a href="#1-2指令的格式" class="headerlink" title="1.2指令的格式"></a>1.2指令的格式</h2><p><img src="https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20221023153906.png"></p><h3 id="按地址码数目分类"><a href="#按地址码数目分类" class="headerlink" title="按地址码数目分类"></a>按地址码数目分类</h3><p><img src="https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20221023153948.png"></p><h3 id="按指令长度分类"><a href="#按指令长度分类" class="headerlink" title="按指令长度分类"></a>按指令长度分类</h3><p><img src="https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20221023155811.png"></p><h3 id="按操作码长度分类"><a href="#按操作码长度分类" class="headerlink" title="按操作码长度分类"></a>按操作码长度分类</h3><p><img src="https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20221023155214.png"></p><h3 id="按操作类型分类"><a href="#按操作类型分类" class="headerlink" title="按操作类型分类"></a>按操作类型分类</h3><p><img src="https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20221023155455.png"></p><h2 id="1-3-拓展操作码"><a href="#1-3-拓展操作码" class="headerlink" title="1.3 拓展操作码"></a>1.3 拓展操作码</h2><p><img src="https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20221023160321.png"></p><p><img src="https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20221023161241.png"></p><p><img src="https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20221023161336.png"></p><h2 id="2-1-指令寻址"><a href="#2-1-指令寻址" class="headerlink" title="2.1 指令寻址"></a>2.1 指令寻址</h2><h2 id="2-2-顺序寻址"><a href="#2-2-顺序寻址" class="headerlink" title="2.2 顺序寻址"></a>2.2 顺序寻址</h2><h3 id="定长指令字结构"><a href="#定长指令字结构" class="headerlink" title="定长指令字结构"></a>定长指令字结构</h3><p><img src="https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20221023162021.png"></p><p><img src="https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20221023161845.png"></p><h3 id="变长指令字结构"><a href="#变长指令字结构" class="headerlink" title="变长指令字结构"></a>变长指令字结构</h3><p><img src="https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20221023162358.png"></p><h2 id="2-3跳跃寻址"><a href="#2-3跳跃寻址" class="headerlink" title="2.3跳跃寻址"></a>2.3跳跃寻址</h2><p><img src="https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20221023163008.png"></p><p><img src="https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20221023162903.png"></p><h2 id="3-1-数据寻址"><a href="#3-1-数据寻址" class="headerlink" title="3.1 数据寻址"></a>3.1 数据寻址</h2><h3 id="1-直接寻址"><a href="#1-直接寻址" class="headerlink" title="1.直接寻址"></a>1.直接寻址</h3><p><img src="https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20221023164227.png"></p><h3 id="2-间接寻址"><a href="#2-间接寻址" class="headerlink" title="2.间接寻址"></a>2.间接寻址</h3><p><img src="https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20221023165649.png"></p><h3 id="3-寄存器寻址"><a href="#3-寄存器寻址" class="headerlink" title="3.寄存器寻址"></a>3.寄存器寻址</h3><p><img src="https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20221023165820.png"></p><h3 id="4-寄存器间接寻址"><a href="#4-寄存器间接寻址" class="headerlink" title="4.寄存器间接寻址"></a>4.寄存器间接寻址</h3><p><img src="https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20221023165919.png"></p><h3 id="5-隐含寻址"><a href="#5-隐含寻址" class="headerlink" title="5.隐含寻址"></a>5.隐含寻址</h3><p><img src="https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20221023170048.png"></p><h3 id="6-立即寻址"><a href="#6-立即寻址" class="headerlink" title="6.立即寻址"></a>6.立即寻址</h3><p> <img src="https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20221023170406.png"></p><p><img src="https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20221023170446.png"></p><h3 id="7-偏移寻址（基址寻址、）"><a href="#7-偏移寻址（基址寻址、）" class="headerlink" title="7.偏移寻址（基址寻址、）"></a>7.偏移寻址（基址寻址、）</h3><p><img src="https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20221023171242.png"></p><h4 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h4><p><img src="https://image.glwsq.cn/img/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2022-03-19-20-01-42.png" alt="基址寻址"></p><p>基址寻址</p><h4 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h4><ul><li><a href="https://image.glwsq.cn/img/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2022-03-19-20-02-08.png" title="变址寻址"><img src="https://image.glwsq.cn/img/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2022-03-19-20-02-08.png" alt="变址寻址"></a><pre><code class="hljs">  [变址寻址](https://image.glwsq.cn/img/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2022-03-19-20-02-08.png &quot;变址寻址&quot;)        [![相对寻址](https://image.glwsq.cn/img/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2022-03-19-20-06-12.png)    相对寻址    ](https://image.glwsq.cn/img/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2022-03-19-20-06-12.png &quot;相对寻址&quot;)</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
      <tag>考试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
