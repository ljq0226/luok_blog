---
title: 设计模式概述（一）
date: 2022/9/13 10:46:25
categories:
- 设计模式
tags:
- 计算机基础
- 考试
---

## 模式
+ Context（模式可适用的前提条件）
+ Theme或Problem（在特定条件下要解决的目标问题）
+ Solution（对目标问题求解过程中各种物理关系的记述）
经典定义：
模式是在**特定环境下**人们解决某类重复出现**问题**的一套成功或有效的**解决方案**。

设计模式(Design Pattern)
+ 一套被**反复使用的、多数人知晓的、经过分类编目的、代码设计经验的**总结
+ 是一种用于对软件系统中不断重现的设计问题的**解决方案**进行**文档化**的技术
是一种**共享**专家设计经验的技术
+ 目的：为了可重用代码、让代码更容易被他人理解、提高代码可靠性

## 设计模式
设计模式是在**特定环境下为**解决**某一通用软件设计**问题提供的一套**定制的解决方案**，该方案描述了对象和类之间的相互作用。

基本要素
+ **模式名称** (Pattern Name) 
+ **问题** (Problem) 
+ **解决方案** (Solution) 
+ **效果** (Consequences) 

分类
根据目的
+ 创建型模式(Creational)主要用于**创建对象**
+ 结构型模式(Structural)主要用于**处理类或对象的组合**
+ 行为型模式(Behavioral)主要用于**描述类或对象如何交互和怎样分配职责**
 根据范围
 + 类模式处理**类和子类之间的关系**，这些关系通过继承建立，在编译时刻就被确定下来，是一种**静态**关系
+ 对象模式处理**对象间的关系**，这些关系在运行时变化，更具**动态**性
 
![](https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20220929112441.png)


优点
+ 融合了众多专家的经验，并以一种标准的形式供广大开发人员所用
+ 提供了一套通用的设计词汇和一种通用的语言，以方便开发人员之间进行沟通和交流，使得设计方案更加通俗易懂
+ 让人们可以更加简单方便地复用成功的设计和体系结构
+ 使得设计方案更加灵活，且易于修改
+ 将提高软件系统的开发效率和软件质量，且在一定程度上节约设计成本
+ 有助于初学者更深入地理解面向对象思想，方便阅读和学习现有类库与其他系统中的源代码，还可以提高软件的设计水平和代码质量

## 面向对象设计原则

[Principles of Object-Oriented Design](http://www.cs.utsa.edu/~cs3443/notes/designPrinciples/designPrinciples.html)

面向对象设计原则为支持**可维护性复用**而诞生,**指导性原则**而非强制性原则，用于评价一个设计模式的使用效果的重要指标之一。
+ 可维护性(Maintainability)：指软件能够被理解、改正、适应及扩展的难易程度
+ 可复用性(Reusability)：指软件能够被重复使用的难易程度



### 单一职责原则

>***一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。***

单一职责原则是最简单的面向对象设计原则，用于**控制类的粒度大小**,就一个类而言，应该仅有**一个引起它变化的原因**

分析
+ 一个类（大到模块，小到方法）**承担的职责越多**，它**被复用的可能性就越小**
+ **当一个职责变化时**，可能**会影响其他职责的运作**
+ 将这些职责进行分离，**将不同的职责封装在不同的类中**
+ 将不同的变化原因封装在不同的类中
+ 单一职责原则是**实现高内聚、低耦合的指导方针**


### 开闭原则

>***软件实体应当对扩展开放，对修改关闭。***

开闭原则是面向对象的**可复用设计的第一块基石**，是**最重要**的面向对象设计原则

分析
在开闭原则的定义中，软件实体可以是一个软件模块、一个由多个类组成的局部结构或一个独立的类
开闭原则是指软件实体应**尽量在不修改原有代码的情况下进行扩展**
**抽象化**是开闭原则的关键
相对稳定的**抽象层** + 灵活的**具体层**
对可变性封装原则(Principle of Encapsulation of Variation, EVP)：找到系统的可变因素并将其封装起来

### 里氏代换原则
>**所有引用基类的地方必须能透明地使用其子类的对象**。

分析
+ 在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象
+ 在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型



### 依赖倒转原则
>高层模块不应该依赖低层模块，它们都应该依赖抽象。**抽象不应该依赖于细节，细节应该依赖于抽象。**

要针对接口编程，不要针对实现编程.
分析
+ 在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等
+ 在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中
+ 针对抽象层编程，将具体类的对象通过依赖注入(Dependency Injection, DI)的方式注入到其他对象

### 接口隔离原则
>**客户端不应该依赖那些它不需要的接口。**

分析
+ 当一个接口太大时，需要将它分割成一些**更细小**的接口
+ 使用该接口的客户端**仅需知道与之相关的方法**即可
+ 每一个接口应该**承担一种相对独立的角色**，不干不该干的事，该干的事都要干

### 合成复用原则(组合/聚合复用原则)
>**优先使用对象组合，而不是继承来达到复用的目的。**

分析
+ 合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分
+ 新对象通过委派调用已有对象的方法达到复用功能的目的
+ 复用时要尽量使用组合/聚合关系（关联关系），少用继承
+ 继承复用：实现简单，易于扩展。破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（“白箱”复用 ）
+ 组合/聚合复用：耦合度相对较低，有选择性地调用成员对象的操作；可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。（“黑箱”复用 ）

### 迪米特法则(最少知识原则)
>每一个软件单位对其他的单位都只有**最少的知识**，而且**局限于那些与本单位密切相关的软件单位**。

分析
+ 迪米特法则要求**一个软件实体应当尽可能少地与其他实体发生相互作用**
+ 应用迪米特法则可**降低系统的耦合度**，使类与类之间保持松散的耦合关系
+ 迪米特法则要求在设计系统时，应该尽量减少对象之间的交互
+ 如果两个对象之间不必彼此直接通信，那么这两个对象就不应该发生任何直接的相互作用
+ 如果其中一个对象需要调用另一个对象的方法，可以通过“第三者”转发这个调用
+ 通过引入一个合理的“第三者”来降低现有对象之间的耦合度
